# 操作系统基础

## 1. 操作系统发展过程

* 早期主机包括中央处理器（CPU）和主存储器两部分，手工操作阶段
  * 特点：资源独占、串行工作、人工干预
  * 缺点：资源浪费、使用不便
  * CPU的计算速度比I/O速度快得多
* 早期批处理阶段：联机/脱机批处理
* 执行系统：处理中断程序、I/O控制程序（有指挥控制权）
* **多道程序系统阶段**

## 2.  操作系统的概念

* 简称OS，operating system。<mark>OS是管理计算机系统资源（硬件和软件）的系统软件</mark>
  * 是软件不是硬件
  * 是系统软件不是应用软件

* 设置OS的目的：**方便用户**、**充分发挥计算机各种资源的效率**
* OS的设计目标：
  * 监视资源、分配资源、回收资源

* OS的目标：
  * 有效性、方便性、可扩充性、开放性

* 作用：底层硬件和用户间的沟通桥梁
* <mark>OS的主要功能：</mark>
  * 处理器（CPU）管理、存储器管理、设备管理、文件管理、工作管理（人机交互）

* <mark>OS的服务功能：</mark>
  * 程序执行、I/O操作、文件系统管理、出错检测、资源分配、统计、保护
  * 方式：系统调用、系统程序

## 3. 操作系统的结构

* <mark>外部结构：硬件、软件、用户</mark>
* 内部结构：**底层——对硬件的控制程序；顶层——系统调用的接口程序；内部：进程、设备、存储、文件系统管理模块**

## 4. 操作系统的分类

* 多道批处理系统   
  * 多道：内存中多个作业同时存在
  * 成批：作业可以一批批地输入系统
  * Spooling技术将作业放入/调出输入/输出井

* 分时系统（多路存取系统）—— **UNIX**
  * 多用户共享，很多终端
  * 分时：时间共享
  * 特点：同时性、交互性、独立性、及时性
* 实时系统
  * 对外部时间进行**及时**响应和处理
  * 特征：及时性、交互性、安全可靠性、多路性

* <mark>现代操作系统：</mark>
  * 网络操作系统：面对不同单机操作系统间的资源共享、用户协调和单机系统交互
  * 分布式操作系统：系统中每台计算机是自主的、用户将整个系统视为一台计算机
  * 嵌入式操作系统——Android、iOS

## 5. 操作系统的特征

* <mark>并发、共享、长期信息存储、不确定性（每次作业执行的次序和时间不一样）、*虚拟*</mark>

## 6. 如何评价一个操作系统的性能

* 效率（没有利用CPU的时间越短越好，批处理作业的周转时间又少越好等）、可靠性、可维护性

## 7. 当前流行的几种微机操作系统

* Windows操作系统
* OS/2操作系统
* UNIX操作系统
* Linux系统（类UNIX操作系统）
* 手机操作系统：Android、iOS

## 8. UNIX系统的特点和结构

* 特点：良好的用户界面、树形结构的文件系统、字符流式文件、丰富的核外程序、对现有技术的精选和发展、系统采用高级语言书写
* 结构：最里层是操作系统；中间层是shell命令解释程序*（这里就是核外了）*；最外层是应用层
* 硬件层、核心层（文件系统、缓冲区管理、进程控制系统等**（进程通信、进程调度、内存管理）**）、用户层



***



# 进程管理

## 1. 进程的概念

* （计算机）程序是一组**计算机能识别和执行的指令**，是满足人们某种需求的信息化工具
  
* 程序的顺序进行
  
* 单道程序环境：顺序性、可再现性、封闭性
  
* 程序的并发执行和资源共享
  
* 多道程序：资源共享、程序并发运行
  
* 程序并发运行的特征
  * 失去封闭性
  * 程序与执行活动不再一一对应
  * 程序之间具有相互依赖与制约关系

* <mark>为什么产生了进程：程序这一静态概念已不足以描述程序并发执行的特征，为了适应这一情况，引入了一个能反应程序并行执行特点的新概念——进程</mark>

* **进程（Process）**
  
  * **<mark>进程是程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位</mark>**
  * 进程是一个动态概念，程序是静态；一个进程可以包含多个程序；进程是暂时的，程序可以作为资料长期保存
  * 同一程序同时运行于不同数据集合上时，它将属于不同的进程
  * 系统分配资源是以进程为单位的
  * 处理机也是按进程分配的
* **特征：动态性、并发性、独立性、制约性（互斥使用资源、相关进程间的同步和通信）、结构性（进程=PCB+程序段+数据段）**
  
* 可以用进程概念说明**操作系统的并发性和不确定性**

* **<mark>进程的状态及变迁</mark>**
  
  * **运行状态：**进程正在占用CPU，其程序在CPU上执行（进程数不能大于CPU数）
  * **就绪状态：**已具备除CPU外的一切运行条件（就绪队列）
  * **封锁状态：**因等待某一事件的到来而暂时不能运行的挂起状态
  * **说明：**
    * 运行与封锁状态的转换是不能互逆的
    * 一个进程从运行状态转换为其他状态时，必导致另一进程从就绪状态转换到运行状态
    * 还有两个短暂状态：**创建状态**——进程正在创建，还未完成； **终止状态**——进程运行完毕，系统正在收回其所占资源
  
  * 运行状态因某一事件变为封锁状态，该事件消除后，被封锁的进程先转为就绪状态，重新由进程调度程序来调度。

* 进程的组成

  * 程序：描述了进程要完成的功能

  * 数据：程序运行时所需的数据和工作区   

    （以上两部分成为进程的实体）

  * 进程控制块（PCB）：一个进程存在的唯一标志，是**描述和控制进程**的数据结构，包括：

    * 进程标识号
    * 特征信息：系统进程还是用户进程等
    * 进程状态信息
    * 调度优先级：一个整数
    * 通信信息：存放进程之间的一些同步互斥信号量、通信指针等
    * 现场保护区：进程交替时保存其程序运行的CPU现场，以便将来的恢复
    * 资源信息：当前已分得了哪些资源
    * 进程映像信息：程序和数据的存储信息、内存外存的地址等
    * 族系关系：指向父进程和子进程的指针
    * 其他信息：因系统而异，文件信息等

  * 常见的PCB组织方式：线表和链接表

## 2. <mark>进程间的相互作用和通信</mark>

* 同步和互斥

  * 同步：多个进程中发生的事件存在某种**时序关系**，需要相互合作，共同完成一项任务
  * 互斥：多个进程之间由于竞争临界资源而相互制约

  * **同步机制遵循的原则：**
    （1）空闲让进
    （2）忙则等待（保证对临界区的互斥访问）
    （3）有限等待（有限代表有限的时间，避免死等）
    （4）让权等待（当进程不能进入自己的临界区时，应该释放处理机，以免陷入忙等状态）

* 临界区和临界资源

  * 临界资源：一次只允许一个进程使用的资源
  * 临界区：每个进程中访问临界资源的那一段程序
  * 原则：一次只允许一个进程进入同类临界区

* 实施临界区互斥的锁操作方法

  * 关锁操作——执行临界区程序——开锁操作

    * 用**开、关中断**实施锁操作

    * bool型变量：Lock-name，0为打开状态，1为关闭状态

      ```c++
      #Lock
      while(Lock-name)==1;
      	Lock-name=1;
      #Unlock
      Lock-name=0;
      ```


* **<mark>进程间的通信</mark>**（进程之间的信息交换）
  * 进程的通信方式主要分为：**管道、系统IPC（包括消息队列、信号量、共享存储等）、SOCKET**
  
    1. 无名管道：管道是一种半双工的通信方式，数据只能单向流动，而且**只能在具有亲缘关系的进程间使用**（父子进程关系）
    
    2. 有名管道 ： 它**允许无亲缘关系进程间的通信**
    
    3. 信号量： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源
    
    4. 消息队列： 消息队列是消息的链表，存放在内核中并由消息队列标识符标识。只有在内核重启(即操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点
    
    5. 信号 ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生
    
    6. 共享内存：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量配合使用，来实现进程间的同步和通信
    
    7. 套接字： 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程
  
  * **几种通信方式的比较：**
    * 管道：速度慢、容量有限
    * 消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题
    * 信号量：不能传递复杂信息，只能用来同步
    * 共享内存：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全

## 3. 线程

* 概念：线程被称为轻量级进程（LWP），是现代操作系统中**为了提高系统的并行能力**而使用的一种比进程更小的程序执行单位
* 线程的特点：
  * 线程对象是轻型实体：实体不拥有资源，但拥有一些必不可少的数据资源，由线程控制块（TCB）描述
  * 线程是独立调度和CPU时间片分配的基本单位
  * 线程可并发执行
  * 同进程的多个线程能共享进程资源

* 线程的状态：创建线程、终止线程、阻塞线程、唤醒线程
* <mark>**线程和进程的区别：**</mark>
  * 进程之间是相互独立的；而线程是进程的一部分
  * 进程比线程包含更多的状态信息，如一个进程中多个线程共享父进程的状态信息
  * 进程拥有独立的内存地址空间，而线程共享父进程的内存空间
  * 进程之间的通信只能通过操作系统提供的进程间通信机制进行
  * 同进程中的线程间切换调度比进程间切换调度快

* 多线程编程：

	* 优点：

		* 响应性：允许一个应用程序保持对输入的响应

		* 更快的执行效率

		* 更少的资源消耗

		* 更好的系统利用率

		* 更简单的共享和通信

		* 并行化

  
  * 弱点：
    * 线程同步：通常使用互斥锁保证多个线程同时修改数据
    * 进程崩溃：一个崩溃全崩溃

* <mark>**线程间的同步方式**</mark>
  
  * **互斥量**：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制
  * **信号量** ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量
  * **事件** ：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较

## 4. 中断处理

* 中断及其一般处理过程
  * <mark>中断：中止正在执行的程序，转而处理更紧急的时间（执行另一段程序）</mark>
  * CPU暂停正在处理的程序，保留现场，处理其他事件，再返回断点，继续执行被打断的程序

* 中断分类：
  * 按功能分类：机器故障中断、I/O中断、外部中断、程序性中断、访管中断
  * 按产生方式分类：强迫中断、自愿中断
  * 按事件来源分类：中断（CPU以外的事件）、陷入（CPU内部事件）

* 中断屏蔽：提出中断请求后，CPU不予响应

* 中断禁止：在可引起中断的事件发生时系统不接受其中断信号

* **中断和轮询：**

    * 轮询：对I/O设备的程序轮询的方式，是早期的计算机系统对I/O设备的一种管理方式，它定时对各种设备轮流询问一遍有无处理要求，轮流询问之后，有要求的，则加以处理。程序轮询占据了CPU相当一部分处理时间，是一种效率较低的方式，在现代计算机系统中已很少应用
    * 轮询——效率低，等待时间很长，CPU利用率不高。
    * 中断——容易遗漏一些问题，CPU利用率高。

***



# 处理机管理

## 1. 概述

* **处理机管理其实就是CPU的分配，即某时某刻调度哪一个进程占用CPU**
* <mark>CPU调度的三级实现：</mark>
  * 高级（长程/作业/宏观）调度：将已进入系统并处于后备状态的作业按照某种算法选择一个或一批，为其建立进程，让其进入主机
  * 中级（中程）调度：负责进程在内存和辅存对换区之间的对换
  * 低级（短程/进程/微观）调度：CPU调度主要就是指的这一级调度
    * 任务：按一定算法在多个已在内存并处于就状态的进程间分配CPU
    * **功能：**保留原运行进程的现场信息；分配CPU；为新选中进程恢复现场
    * **引起调度原因：**进程自动放弃CPU、CPU被抢占

* 进程的执行方式：

  * 每一个进程的执行往往是**CPU周期和I/O周期的交替循环**

  * I/O周期：这段时间内进程提出了I/O请求，并等待I/O的完成
  * 直到最后一个CPU周期终止其执行

* CPU调度的基本方式

  * 剥夺方式：正在执行的CPU周期尚未结束前就有权剥夺它的CPU
  * 非剥夺方式：除非周期到期并主动放弃，不得剥夺

## 2. <mark>（进程的）常用调度算法</mark>

* 先来先服务 FCFS：
  * 总是把CPU分配给当前处于就绪队列之首的那个进程，只考虑进入就绪队列的先后
  * 简单易行，性能不高，本质是非剥夺方式
* 最短周期优先 SBF：
  * 总是调度当前就绪队列中的下一个CPU周期最短的那个进程占用的CPU
  * 平均周转时间是最优的，但实行起来很困难（下一个CPU周期不知道多长）
* 优先级：将CPU分给优先级最高的进程，**关键：确定各进程 的优先级**
  * 静态确定方法：系统创建进程时确定一个优先级，一经确定不再改变
  * 动态优先级：进程运行过程中，随着某些条件的变化不断地修改其优先级（简单方法：当一个进程等待时间达到某一定值时，其优先级就可以跃变到某一个最高值，从而能够很快转入执行状态
* 轮转法：
  * 按一定的时间片q轮转地运行各个进程。若q值一定，即割割进程运行同样长的时间片，轮转法是一种机会均等的调度方法
  * 所有就绪进程的PCB排成一个环形队列，使用一个指针扫描他们
  * 本质时剥夺式的
  * 关键：如何确定时间片的大小（批处理系统应使80%左右的CPU周期在一个时间片内完成）
* 可变时间片轮转法：每一轮周期开始时，根据就绪队列中进程数目计算出这一轮的时间片q值
* 多队列轮转法和多级反馈队列法：
  * 多队列轮转法：根据进程的特性，永久性地将各个进程分别链入其中某一就绪队列中。（例：高优先级的前台队列，低优先级的后台队列，进程不能在队列中移动）
  * 多级反馈队列法：允许进程在各队列间移动；每个队列有自己的调度算法；总是先调度序数较小的就绪队列中的进程。
* UNIX系统中的进程调度
  * 与多级反馈队列轮转法比较接近
  * 进程在核心态下运行时，除非自动放弃CPU，不进行重新调度
  * 用户态下的进程可以根据其优先级高低进行进程的调度，系统为用户态下的进程定期计算其优先数



***



# 存储管理

## 1. 引言

* 存储器是系统中的关键资源之一，能否合理而有效地使用这种资源，在很大程度上会影响整个计算机系统的性能
### 二级存储器及信息传送

  * OS中的内存（或称主存）是处理机可以直接存取信息的存储器；一个进程要在处理机上运行，就一定要先占用一部分内存，否则无法执行程序，也无法取用所需数据；内存是进程得以活动的物质基础之一
  * 内存优点是速度快，可以随机存取，但价格比较贵
  * OS普遍采用二级存储器结构：第一级是内存，第二级是外存，外存通常用的是磁盘或磁盘上的一部分区域
  * CPU不能直接从外存上存取指令和数据，所以带来了内外存之间信息的传送问题（换入和换出）
  * 把耳机存储器有机地组织起来，一方面扩大了存储器容量，另一方面自动地实现二级存储器之间的信息传送，这是存储管理的一种重要功能
### 存储器分配

* 问题提出的原因：
  * 存储器为多个进程共享，进程是动态创建和终止的
  * 运行过程中，进程所需的存储区大小随时可能发生变化
  * 进程执行的程序及有关数据可能存放在内存或外存中
  * 系统为了充分利用存储资源，有时需要改动某些进程占用的存储区位置
### 存储管理的基本任务
  * OS中，存储管理模块主要是指内存管理；作为内存的扩展和延伸的外存是放在设备管理中介绍的。

  * 内存空间主要有两大部分，系统态区和用户态区，如图：
    <img src="C:\Users\admin\Desktop\暑期实习冲啊\四大件冲刺学习\内存外存.png" alt="avatar" style="zoom:50%;" />

    系统态区一般存放常驻内存程序，不在多道程序之间分配；用户态区存放用户程序和运行在用户态下的系统程序，由多道程序共享；所以<mark>存储管理对于内存来讲主要是管理其用户态区</mark>

  * 外存比内存容量大很多，主要存放后备作业，为I/O提供输入/输出井，为虚存提供物质基础

  * 存储管理要实现的目标：方便（用户把逻辑地址和物理地址分开）；安全（多个驻留在内存中的进程互不干扰）；充分大（用户程序需要多大的内存空间，就能提供多大的空间）

  * **<mark>基本任务：</mark>**

    * 按某种算法分配和回收存储空间
    * 实现逻辑地址到物理地址的转换
    * 由软/硬件共同实现程序间的相互保护

### 存储空间的地址问题

<img src="C:\Users\admin\Desktop\暑期实习冲啊\四大件冲刺学习\地址空间.png" alt="avatar" style="zoom:70%;" />

* 程序中通过符号名称来调用、访问子程序和数据，这些符号的集合被称为名空间
* 经过编译/汇编后，形成了一种由机器指令组成的集合，被称为目标程序，这些目标程序指令的顺序都以0为一个参考地址，这些地址被称为相对/逻辑/虚拟地址，集合称为相对地址空间
* **目标程序要装入系统内存才能运行。**<mark>将目标地址中以0为参考点的指令序列，转换为以一个实际的存储器单元地址为基准的指令序列**（重定位）**</mark>，才可以成为一个可以被CPU调用执行的程序，它被称为绝对目标/执行程序，地址集合称为绝对地址空间

### 地址转换

* 重定位在实际中有两种情况：
  * 一个程序装入内存运行时，根据其分得的空间位置将程序的逻辑地址变换成相应的物理地址
  * 程序执行过程中，由于某些原因在内存移动了位置后，需要将程序的逻辑地址重新变换，以便程序重新定位在新的位置上
* 根据地址变换时机，重定位分为：
  * 静态重定位：在程序执行前进行重定位，由**重定位装配程序**完成
    * 优点：无需硬件支持，地址映射简单容易实现
    * 缺点：一旦重定位完成就不能在存储器中再搬移程序，要求程序存放的空间是连续的，不利于内存空间有效利用
  * 动态重定位：程序执行过程中，CPU访问内存之前，由**硬件地址映射机构**来完成（通常是**BR重定位寄存器**）
    * 优点：目标程序无需任何改动即可装入内存；装入后程序代码可以任意移动，只改变BR的内容即可；有利于程序分块，每个程序模块各自装入一个存储区，不一定顺序相连，有利于存储空间利用；便于动态链接
    * 缺点：增加硬件支持，实现存储管理的软件算法较为复杂

### <mark>存储管理的功能</mark>

* 存储分配：记录存储器的使用情况，响应存储器申请，根据分配策略分配内存，回收内存
* 地址变换：进行程序的相对地址到物理地址的转换，也完成虚拟地址空间到物理存储空间的映射
* 存储扩充：内存容量尽管受到实际存储单元的限制，但可以采用某种技术使内存的可使用容量在逻辑上扩大
* 存储共享与保护：共享存放于某个内存中的程序、共享内存缓冲区存放数据；对共享区进行保护，互不干扰，互不侵犯

### 内存的扩充技术

* 覆盖技术：利用程序内部结构的特征，以较小的内存空间运行较大程序的技术
* 交换技术：内外存之间交换信息
* **<mark>虚拟存储器技术</mark>**： 为了给大作业提供方便，操作系统把多级存储器统一管理起来，实现自动覆盖；这样的OS好像为用户提供了一个存储容量比实际主存大得多的存储器，故被称为虚拟存储器；容量=内存+外存
  * 主要技术是程序的“部分装入”（开始执行时只装入一部分）和“部分对换”（需要腾出内存空间时部分对换到外存）
  * 实现虚存管理的物质基础：二级存储器结构和动态地址转换机构DAT

### <mark>虚拟内存的补充（和虚拟存储器一样）</mark>

* 概念：虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）；虚拟内存的重要意义是它定义了一个连续的虚拟地址空间，并且把内存扩展到硬盘空间

* **局部性原理：**局部性原理是虚拟内存技术的基础，正是因为程序运行具有局部性原理，才可以只装入部分程序到内存就开始运行
  * 程序在执行的时候往往呈现局部性规律，也就是说在某个较短的时间段内，程序执行局限于某一小部分，程序访问的存储空间也局限于某个区域
  * 局部性原理表现在以下两个方面：
    * **时间局部性** ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作
    * **空间局部性** ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的

## 2. 分区式管理技术

* 固定分区法：处理作业之前，先把内存划分为若干个固定的分区（OS本身占用一个分区）

  * 这种分区的内/外零头之和构成了存储器总的浪费
* 可变分区法：在运行过程中，根据作业的实际需要动态地分割内存空间（需要设计有效的分配算法）
* 可以采用表格法（分配表、未分配表）、位图法、链接法
  * 需要硬件支持（通常是一对寄存器）
  

## 3. 可重定位分区分配

* 概念：在分区分配中采用“紧凑”技术（移动某些已分配区的内容，使作业分区挨在一起，使空闲区“零头”变成大的自由块）
* 紧凑时机：当某分区被回收时，若没有和其他空闲区挨着；要分配存储空间时，不能满足需求
* 时间换空间

## 4. 多道程序对换技术

* 最初的整体对换会导致耗时浪费
* “洋葱皮”：对作业，只有部分信息需要对换，利用外存解决了内存小的问题

## 5. 分页存储管理

### 分页管理

* 基本思想：把程序的逻辑空间和内存的物理空间按同样尺寸划分成若干个页面，分配以页面为单位（一个进程的程序一次装入）
  * 内存的存储空间划分的页面称为“块”
  * 允许程序的存储空间是不连续的，解决了外部碎片问题，提高了内存利用率
* 数据结构：需建立两种表格
  * 一是<mark>存储分块表MBT</mark>，整个系统一张表，用以记录各物理块的分配使用情况
    * 表目个数等于物理块数，每个表目有三个数据项：标志（块是否已分）、进程号、页面号；附在最后的变量n记录当前自由块的个数
  * 二是<mark>页表PT</mark>，每个进程一张表，用以记录该进程的各个页面分在哪些物理块内
    * 实现地址变换的机构要求为每页设置一个重定位寄存器，这些寄存器组成一组称为页表
    * 每个表目主要记录一个数据，相应的物理块号；表目数目等于其记录的逻辑空间的页面数；<mark>每张页表长度相等</mark>
* 地址变换：
  * 由动态地址转换机构自动地将CPU给出的一维逻辑地址LA分成两部分：页号p和页内位移量b
  * 按p值查找现行进程页表以获得块号n
  * 将此块号n与LA中的b拼接，就形成了物理地址PA

* **快表及快速地址变换：**
  * 在CPU和内存之间设一个高速、小型的相连存储器，称为快表，用它存放正在运行的作业最常用的页号和与之对应的物理块号
  * 可以把快表理解为一种特殊的高速缓冲存储器（Cache），其中的内容是页表的一部分或者全部内容。作为页表的 Cache，它的作用与页表相似，但是提高了访问速率
  * 使用快表的地址转换流程：
    * 根据虚拟地址中的页号查快表
    * 如果该页在快表中，直接从快表中读取相应的物理地址
    * 如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中
    * 当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页
  * 快表和我们平时经常在我们开发的系统使用的缓存（比如 Redis）很像

### 请求分页管理

<mark>在分页存储管理的基础上加上虚拟存储器技术而形成</mark>

* 基本思想：进程执行之前，只装入一个或若干个页面，然后根据程序执行的需要动态地装入其他页面。当内存装满，又有新的页面要装入时，根据淘汰算法淘汰一个页面
* 页表包含了更多信息，比如改变位、状态位、引用位
* 淘汰算法（页面替换）：
  * 最佳置换算法（自然页流）：将未来最久不使用的页替换出去（无法实现）
  * 先进先出算法FIFO：淘汰在内存中最久的页
  * 最久未使用算法：淘汰最近最长未使用的页
  * 第二次机会算法：在FIFO的基础上，为了避免淘汰经常使用的页，增加一个标志位R，如果最近使用过将R置1，当页将会淘汰时，如果R为1，则不淘汰页，将R置0
  * 时钟替换算法：在改进型FIFO算法的基础上，将队列首位相连形成一个环路，当缺页中断产生时，从当前位置开始找R=0的页，而所经过的R=1的页被置0，不需要移动页

## 6. 段式存储管理

### 分段和分段的地址空间

* 分段也叫做段。段在逻辑上是一组整体的信息，每段都有自己的名字（段号），而且都是一段连续的地址空间——可见整个作业的逻辑空间是二维的
* 它可以是主程序、子程序、数据和工作区等
* <mark>页是信息的物理单位，大小固定由系统确定，用户看不见；而段是信息的逻辑单位，大小可变，由用户确定</mark>
* 分段管理下，一个段必须分配在一片连续区域之中，但整个程序不要求在内存中全部连续
* 指令和数据的单元地址均由两部分组成：**段号和段内位移W**
* 分段管理也可以加进虚存管理，内存和外存之间交换时以段位单位进行
* 把一维的物理空间改造成用户可见的二维逻辑空间

### 分段管理的实现

* 段表：从逻辑地址到物理地址的转换是通过段表进行的
  * 每个进程一张段表，记住与该进程有关的逻辑段的信息
  * 段表中每个表目由四个数据项：段长、存取权（保护用，分为可读、可写、可执行）、状态（该段是否在内存中，在虚存管理使用）、起始地址
  * 各分段要整体装入，所以其内存分配也必须同时能满足一个进程的各段要求方可分配
* 地址变换过程：
  * CR给出段表初始地址，CPU给出s、w，s+段表起址=段表项
  * 段表中的段长与w比较，若w>段长则越界（中断处理），否则w+段起址=PA（物理地址）

### 分段共享

* 分段是由逻辑意义的整体，因此共享有意义
* 不同的进程可以与不同的逻辑段号共享同一分段

### 段的动态链接

* 加入虚拟存储器管理，成为段式虚拟存储系统
* 一个作业所有分段保存在外存中，运行时需要把当前需要的段装入主存
* 大作业往往由若干程序模块组成，最好在需要调用一个模块时再去链接它，这就是动态链接法
* 动态链接的过程：
  * 间接编址和连接中断位
  * 编译程序的工作——链接准备
  * OS的工作——链接中断处理

## 7. 段页式存储管理

### 基本思想

* 一个作业（进程）按逻辑结构分成若干段，再把每一段分成若干页面
* 分配内存时，一个页面装入一个内存块，同一段的若干页面再内存中可以不连续

### 实现过程

* 段表和页表
  * 段表ST：每个进程一张，记录进程中各段的页表起址和长度等
  * 页表PT：每段一张，记录每一页所分得的内存物理块号

* 地址变换过程，见图
* 段页式将段式和页式的优点兼收：
  * 使得面向用户的地址空间按程序结构划分，而物理存储空间按页划分
  * 段内各页不必同时在内存中，节省了存储空间，段长也可以超过内存空间
  * 段内各页不论在内存还是外存，都不必连续分布，使得存储器分配易于实现

* 段页式的代价是：地址变换机构更复杂，段、页表使用的存储空间增加



***



# 设备管理

## 1. 概述

### 设备分类

* 按从属关系分：系统设备（操作系统生成时即登记）、用户设备
* 按工作特性分：存储设备（外存）、I/O设备（计算机同外界交换信息的工具）
* 从资源分配角度分：独占设备（进程独占，打印机）、共享设备、虚拟设备

### 设备管理的目标和功能

* 目标
  * 向用户提供使用方便且独立于设备的界面
  * 提高各种外设的使用频率
  * 设备管理系统要简练、可靠、易于维护
* 功能
  * 冲区管理
  * 地址转换和设备驱动
  * I/O调度
  * 中断管理

### 设备分配技术

* 设备分配原则一般和下面因素有关：
  * 设备的固有属性
  * 分配算法
  * 防止死锁发生
  * 用户程序与具体物理设备无关
  * 分配技术主要有：独占、共享、虚拟三种方式

### 通道技术

* I/O控制方式的演变
  * 循环测试I/O方式
  * 程序中断方式
  * 通道I/O方式
* 通道的分类
  * 字节多路通道
  * 选择通道
  * 成组多路通道
* 通道、设备和控制器的多路连接

* 通道与CPU之间的通信
  * CPU->通道：CPU执行自己的I/O指令
  * 通道->CPU： 通道完成任务后，用中断方式向CPU汇报
